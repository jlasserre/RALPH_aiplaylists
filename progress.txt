## Codebase Patterns
- Next.js 16.1.2 with App Router (src/app/ directory structure)
- TypeScript strict mode enabled
- Tailwind CSS v4 with `@import "tailwindcss"` syntax
- Path alias `@/*` maps to `./src/*`
- Jest 30 with next/jest helper for Next.js integration
- Tests co-located with source files (`.test.ts`, `.test.tsx`)
- localStorage is mocked in jest.setup.js - mocks auto-clear before each test
- Web Crypto API (TextEncoder, crypto.subtle) polyfilled in jest.setup.js for jsdom

---

## 2026-01-15 - US-001
- What was implemented: Initialized Next.js project with TypeScript and Tailwind CSS
- Files changed:
  - package.json - project config with ai-playlist-generator name
  - tsconfig.json - TypeScript config with strict mode
  - src/app/layout.tsx - root layout with metadata
  - src/app/page.tsx - basic home page component
  - src/app/globals.css - Tailwind CSS imports and theme variables
  - eslint.config.mjs - ESLint configuration
  - next.config.ts - Next.js configuration
  - postcss.config.mjs - PostCSS config for Tailwind
- **Learnings for future iterations:**
  - create-next-app refuses to create projects in directories with capital letters in the name - use temp directory workaround
  - next-env.d.ts is auto-generated and gitignored - don't try to add it
  - Next.js 16 uses Tailwind v4 with new `@import "tailwindcss"` syntax instead of @tailwind directives
---

## 2026-01-15 - US-002
- What was implemented: Installed dependencies and created environment config
- Files changed:
  - package.json - added zustand, @anthropic-ai/sdk, openai dependencies
  - package-lock.json - updated with new dependencies
  - .env.local.example - created with Spotify OAuth and LLM API key placeholders
  - src/types/index.ts - created with comprehensive type definitions (Song, SpotifyTrack, PlaylistSong, CandidateSong, API responses, etc.)
  - .gitignore - added exception for .env.local.example
- **Learnings for future iterations:**
  - .gitignore has `.env*` pattern that blocks .env.local.example - need to add explicit exception `!.env.local.example`
  - Type definitions created early help maintain consistency across the codebase
---

## 2026-01-15 - US-002b
- What was implemented: Set up Jest and React Testing Library for unit and component testing
- Files changed:
  - package.json - added jest, @testing-library/react, @testing-library/jest-dom, jest-environment-jsdom, @types/jest, ts-node; added test/test:watch/test:coverage/typecheck scripts
  - jest.config.js - created with next/jest helper, jsdom environment, module aliases
  - jest.setup.js - created with @testing-library/jest-dom import and localStorage mock
  - src/types/index.test.ts - sample test file verifying types and localStorage mock
- **Learnings for future iterations:**
  - Use `next/jest` helper (createJestConfig) for seamless Next.js integration
  - Jest 30 works with Next.js 16 - no compatibility issues
  - localStorage mock should clear mocks in beforeEach to ensure test isolation
  - The `typecheck` script (`tsc --noEmit`) is useful for CI validation
---

## 2026-01-15 - US-003
- What was implemented: PKCE utility functions for Spotify OAuth
- Files changed:
  - src/lib/spotify/auth.ts - created with generateCodeVerifier, generateCodeChallenge, generateRandomState functions
  - src/lib/spotify/auth.test.ts - comprehensive tests for all PKCE functions
  - jest.setup.js - added TextEncoder, TextDecoder, and crypto.subtle polyfills for Web Crypto API support
- **Learnings for future iterations:**
  - jsdom environment doesn't include TextEncoder/TextDecoder - import from 'util' and set on global
  - jsdom doesn't have crypto.subtle - use webcrypto from 'crypto' module and define on global.crypto
  - Jest 30 uses `--testPathPatterns` instead of `--testPathPattern` (or just pass file path directly)
  - RFC 7636 PKCE test vector: verifier "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk" produces challenge "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM"
---

## 2026-01-15 - US-004
- What was implemented: Spotify OAuth initiation API route
- Files changed:
  - src/app/api/auth/spotify/route.ts - GET handler that generates PKCE values, stores them in httpOnly cookies, and redirects to Spotify authorization
- **Learnings for future iterations:**
  - Next.js 16 cookies() is async - must await the call before using set()
  - Cookie options: httpOnly for security, sameSite 'lax' for OAuth redirects, secure in production only
  - Spotify OAuth scopes: playlist-read-private, playlist-modify-public, playlist-modify-private are needed for this app
  - Store both code_verifier (for token exchange) and state (for CSRF protection) in cookies
---

## 2026-01-15 - US-005
- What was implemented: Spotify OAuth callback API route that completes the PKCE flow
- Files changed:
  - src/app/api/auth/spotify/callback/route.ts - GET handler that exchanges auth code for tokens
- **Learnings for future iterations:**
  - When setting/deleting cookies in a redirect response, use `response.cookies.set()` and `response.cookies.delete()` instead of the `cookies()` store directly
  - Spotify returns tokens as JSON with: access_token, token_type, scope, expires_in, refresh_token
  - Store both refresh_token (30 days) and access_token (expires_in from response) in httpOnly cookies
  - The access_token cookie is temporary - it will be read by /api/auth/refresh on page load
  - Clear temporary OAuth cookies (state, code_verifier) on successful token exchange
---

## 2026-01-15 - US-006
- What was implemented: Token refresh API route for session persistence
- Files changed:
  - src/app/api/auth/refresh/route.ts - POST handler that refreshes access tokens
- **Learnings for future iterations:**
  - Spotify refresh token grant uses `grant_type: 'refresh_token'` with client_id and refresh_token
  - Spotify may return a new refresh_token in the response - update the cookie if so
  - Check for existing access_token cookie first (from OAuth callback) before using refresh_token
  - Clear refresh_token cookie on 400/401 errors (invalid/expired token)
  - Return `expires_in` along with access_token so client knows when to refresh
---

## 2026-01-15 - US-007
- What was implemented: Auth Zustand store for managing Spotify authentication state
- Files changed:
  - src/store/authStore.ts - Zustand store with accessToken, isAuthenticated, isLoading state and actions
  - src/store/authStore.test.ts - 13 tests for all store actions and state transitions
- **Learnings for future iterations:**
  - Zustand stores can be tested by using `useStore.getState()` and `useStore.setState()` directly
  - Reset store state in `beforeEach` using `useStore.setState()` for test isolation
  - Zustand `create<T>()` accepts a generic for full type inference
  - Access token stored in memory only (not persisted) - refresh token is in httpOnly cookie server-side
---

## 2026-01-15 - US-008
- What was implemented: useSpotifyAuth hook with auto-refresh on mount
- Files changed:
  - src/hooks/useSpotifyAuth.ts - hook that auto-refreshes access token on mount, exports login/logout functions
  - src/hooks/useSpotifyAuth.test.ts - 11 tests covering auto-refresh, login, logout, error handling
  - src/store/authStore.ts - added hasAttemptedRefresh state for test isolation
  - src/store/authStore.test.ts - added 4 tests for hasAttemptedRefresh state
- **Learnings for future iterations:**
  - useRef values persist across Jest tests since the module is cached - use store state instead for flags that need test isolation
  - jsdom's window.location.href cannot be redefined - test login function existence rather than actual navigation behavior
  - React Testing Library's renderHook requires async/await with waitFor for async effects
  - Zustand store state can be reset in beforeEach using `useStore.setState()` for proper test isolation
---

## 2026-01-15 - US-009
- What was implemented: Base UI components with Tailwind CSS
- Files changed:
  - src/components/ui/Button.tsx - button with primary/secondary/ghost variants, sm/md/lg sizes, loading state
  - src/components/ui/Input.tsx - input with label, error, hint support
  - src/components/ui/TextArea.tsx - textarea with character count, label, error, hint
  - src/components/ui/Card.tsx - card with optional header section
  - src/components/ui/Checkbox.tsx - checkbox with label and optional description
  - src/components/ui/index.ts - barrel export for all UI components
- **Learnings for future iterations:**
  - forwardRef is useful for components that need to accept refs (Button, Input, TextArea, Checkbox)
  - useId() hook generates stable unique IDs for accessibility (label-input association)
  - ARIA attributes: aria-invalid, aria-describedby for form validation
  - Tailwind focus states: focus:ring-2 focus:ring-offset-2 for accessibility
---

## 2026-01-15 - US-010
- What was implemented: ThreePanelLayout component for desktop/tablet three-panel UI
- Files changed:
  - src/components/layout/ThreePanelLayout.tsx - responsive three-panel layout with left (narrower), middle, and right panels
  - src/components/layout/index.ts - barrel export for layout components
  - src/app/page.tsx - updated to use ThreePanelLayout with placeholder content
- **Learnings for future iterations:**
  - Use flex-shrink-0 for fixed-width panels to prevent them from shrinking
  - Use min-w-0 on flex children to allow proper text truncation
  - overflow-y-auto on panel containers enables independent scrolling per panel
  - The header slot pattern is useful for layout components that need to accept dynamic header content
  - Background color differentiation (bg-gray-50 vs bg-white) helps visually distinguish panels
---

## 2026-01-15 - US-011
- What was implemented: LeftPanel component with playlist controls
- Files changed:
  - src/components/layout/LeftPanel.tsx - full-featured left panel with all required controls
  - src/components/layout/index.ts - added LeftPanel to barrel export
  - src/app/page.tsx - updated to use LeftPanel component
- **Learnings for future iterations:**
  - Custom select styling requires `appearance-none` and a positioned chevron icon
  - The 'use client' directive is needed for components using useState
  - Prompt validation with min/max length can use both TextArea's built-in props and custom error state
  - LLMProvider type should be 'claude' | 'openai' to match PRD requirements
  - The LeftPanel accepts optional callbacks (onNewPlaylist, onLoadExisting, onSuggestSongs) to be wired up by parent
---

## 2026-01-15 - US-012
- What was implemented: MiddlePanel component with CandidateList for displaying song candidates
- Files changed:
  - src/components/layout/MiddlePanel.tsx - panel wrapper with skeleton loading state
  - src/components/features/playlist/CandidateList.tsx - candidate list with checkboxes, empty state, match rate, Add Selected button
  - src/components/features/playlist/index.ts - barrel export for playlist features
  - src/components/layout/index.ts - added MiddlePanel export
  - src/app/page.tsx - updated to use MiddlePanel component
- **Learnings for future iterations:**
  - Use Checkbox with empty label="" when label is provided separately (ARIA handled via aria-label)
  - CandidateSong type from @/types includes isMatched and isSelected for managing selection state
  - Unmatched songs should be disabled (not selectable) and show "Not found" badge
  - Match rate shown as "X of Y songs found on Spotify" helps user understand search quality
  - Skeleton loaders in MiddlePanel show 6 placeholder cards with animated pulse effect
---

## 2026-01-15 - US-013
- What was implemented: RightPanel component with PlaylistView for displaying accumulated playlist songs
- Files changed:
  - src/components/layout/RightPanel.tsx - panel wrapper with skeleton loading state
  - src/components/features/playlist/PlaylistView.tsx - playlist view with state icons, tooltips, song list, read-only banner, and Create/Update button
  - src/components/features/playlist/index.ts - added PlaylistView export
  - src/components/layout/index.ts - added RightPanel export
  - src/app/page.tsx - updated to use RightPanel component
  - eslint.config.mjs - added jest.config.js and jest.setup.js to globalIgnores to fix lint error
- **Learnings for future iterations:**
  - PlaylistSong type from @/types includes state field with values 'synced' | 'pending' | 'markedForRemoval'
  - Use CSS group/group-hover pattern for showing tooltips on hover without JavaScript
  - Read-only banner uses amber colors (bg-amber-50, border-amber-200, text-amber-800) for warning states
  - Skeleton loaders in RightPanel match MiddlePanel pattern with 6 placeholder cards
  - The eslint.config.mjs needed CommonJS files (jest.config.js, jest.setup.js) in globalIgnores to avoid @typescript-eslint/no-require-imports error
---

## 2026-01-15 - US-014
- What was implemented: SongCard component with state icons and tooltips
- Files changed:
  - src/components/features/playlist/SongCard.tsx - reusable song card with state icons (synced, pending, markedForRemoval), tooltips, and click handler
  - src/components/features/playlist/PlaylistView.tsx - updated to use SongCard component instead of inline rendering
  - src/components/features/playlist/index.ts - added SongCard export
  - src/app/page.tsx - added demo data for development testing (demoPlaylistSongs, demoCandidateSongs)
- **Learnings for future iterations:**
  - Extract reusable components (like SongCard) when rendering patterns are duplicated across components
  - State icons with tooltips can use CSS group/group-hover pattern for hover effects
  - The SongCard component supports both playlist (with state icons) and candidate (without state icons) use cases via props
  - Demo data in page.tsx is useful for visual testing during development before stores are wired up
  - Separate icon components (SyncedIcon, PendingIcon, MarkedForRemovalIcon) improve readability and maintainability
---

## 2026-01-15 - US-015
- What was implemented: LLM types and prompt templates for song generation
- Files changed:
  - src/types/song.ts - created with Song interface (title, artist, album?, year?), LLMSongGenerationResponse, and LLMPlaylistNameResponse
  - src/lib/llm/prompts.ts - created with SONG_GENERATION_SYSTEM_PROMPT (instructs LLM to return JSON array of songs), PLAYLIST_NAME_SYSTEM_PROMPT, buildSongGenerationPrompt(), buildPlaylistNamePrompt(), and LLMGenerationConfig types
- **Learnings for future iterations:**
  - Song interface already existed in src/types/index.ts but creating dedicated src/types/song.ts provides clearer separation for LLM-specific types
  - System prompts should explicitly instruct the LLM to return only JSON without markdown formatting or additional text
  - LLMGenerationConfig includes songCount, maxTokens, and temperature for customizing generation behavior
  - Default song generation targets 20 songs with temperature 0.7 for balanced creativity
  - Playlist name generation uses higher temperature (0.8) for more creative names
---

## 2026-01-15 - US-016
- What was implemented: Claude LLM client for song generation
- Files changed:
  - src/lib/llm/claude.ts - ClaudeClient class with generateSongs() and generatePlaylistName() methods
  - src/lib/llm/claude.test.ts - 23 tests covering song generation, name generation, and error handling
- **Learnings for future iterations:**
  - Anthropic SDK v0.71+ uses `messages.create()` with model, max_tokens, system, and messages params
  - Response structure: `response.content` is an array of blocks - find `type: 'text'` block and access `.text`
  - ClaudeAPIError custom class with statusCode and isRetryable properties helps callers handle errors appropriately
  - 429 (rate limit) and 5xx (server errors) should be marked as retryable; 401 (auth) should not
  - Mock Anthropic.APIError in tests by creating object with `status` property and setting prototype to APIError.prototype
  - LLM may return markdown code blocks despite instructions - always strip ```json...``` from responses
  - Validate Song objects by checking title/artist are non-empty strings; filter out invalid songs from response
---

## 2026-01-15 - US-017
- What was implemented: OpenAI LLM client for song generation
- Files changed:
  - src/lib/llm/openai.ts - OpenAIClient class with generateSongs() and generatePlaylistName() methods
  - src/lib/llm/openai.test.ts - 25 tests covering song generation, name generation, and error handling
- **Learnings for future iterations:**
  - OpenAI SDK uses `chat.completions.create()` with model, max_tokens, temperature, and messages params
  - Response structure: `response.choices[0].message.content` for the text content
  - OpenAI uses `{ role: 'system', content }` in messages array instead of separate system param like Anthropic
  - Check for `message.content === null || message.content === undefined` instead of `!message.content` to allow empty string handling
  - Mock OpenAI.APIError in tests same way as Anthropic - create object with `status` property and set prototype
  - Both clients follow same pattern: custom error class with statusCode/isRetryable, parseSongsResponse, isValidSong, handleError
---

## 2026-01-15 - US-018
- What was implemented: LLM factory with provider selection
- Files changed:
  - src/lib/llm/index.ts - LLM factory module with getLLMClient(), getDefaultProvider(), LLMClient interface, LLMProvider type, and re-exports
  - src/lib/llm/index.test.ts - 23 tests covering factory selection, client interface, default provider, and module exports
- **Learnings for future iterations:**
  - When re-exporting types with isolatedModules enabled, use `export type { X }` syntax for types and `export { Y }` for values
  - Mock both @anthropic-ai/sdk and openai SDKs in factory tests to avoid API key validation errors in constructors
  - LLMClient interface provides unified API across providers: generateSongs() and generatePlaylistName()
  - getDefaultProvider() reads from LLM_DEFAULT_PROVIDER env var, defaults to 'claude' if not set or invalid
---

## 2026-01-15 - US-019
- What was implemented: Song generation API endpoint
- Files changed:
  - src/app/api/generate/route.ts - POST handler for song generation with prompt/provider validation and LLM integration
- **Learnings for future iterations:**
  - Use `await request.json()` with try/catch to handle invalid JSON bodies gracefully
  - Import both ClaudeAPIError and OpenAIAPIError from LLM factory to handle provider-specific errors
  - Map LLM 401 errors to 500 for client (since it's a server config issue, not client auth)
  - Map LLM 5xx errors to 502 (bad gateway) since the upstream LLM service failed
  - Include `isRetryable` in error responses so client can show retry button appropriately
---

## 2026-01-15 - US-020
- What was implemented: Playlist name suggestion API endpoint
- Files changed:
  - src/app/api/generate/suggest-name/route.ts - POST handler for playlist name suggestion with prompt/provider validation and LLM integration
- **Learnings for future iterations:**
  - Follow the established pattern from /api/generate/route.ts for consistent API design
  - LLMClient interface already includes generatePlaylistName() method, so integration is straightforward
  - Use same validation rules (10-5000 chars) for consistency across generate endpoints
  - Error handling pattern with ClaudeAPIError and OpenAIAPIError is reusable across all LLM endpoints
---

## 2026-01-15 - US-021
- What was implemented: SpotifyClient class with authenticated request handling
- Files changed:
  - src/lib/spotify/api.ts - SpotifyClient class with private fetch wrapper, HTTP methods (get/post/put/delete), and error handling
  - src/lib/spotify/api.test.ts - 30 tests covering all HTTP methods, error scenarios, and edge cases
- **Learnings for future iterations:**
  - Use custom error classes (SpotifyAuthError, SpotifyRateLimitError, SpotifyAPIError) for typed error handling
  - SpotifyRateLimitError includes `retryAfter` property from Retry-After header for backoff implementation
  - SpotifyAPIError has `isRetryable` flag set to true for 5xx errors, false for 4xx errors
  - Global fetch can be mocked in Jest by assigning to `global.fetch = jest.fn()`
  - Handle 204 No Content responses by returning empty object (DELETE requests often return 204)
  - Spotify error responses have structure `{ error: { message: string } }` - extract message from this path
---

## 2026-01-15 - US-022
- What was implemented: Spotify track search with fuzzy matching
- Files changed:
  - src/lib/spotify/api.ts - Added searchTrack(title, artist) method and fuzzy matching utilities (normalizeString, levenshteinDistance, calculateSimilarity, fuzzyMatch)
  - src/lib/spotify/api.test.ts - Added 34 tests for fuzzy matching utilities and searchTrack method
- **Learnings for future iterations:**
  - Use Levenshtein distance for calculating edit distance between strings (substitution, insertion, deletion)
  - Normalize strings before matching: lowercase, remove accents (NFD + diacritics regex), remove punctuation
  - Spotify search API accepts `track:title artist:artist` query format with `type=track` parameter
  - When handling multi-artist tracks, check if ANY artist matches (using .some())
  - Containment check (includes) catches cases where one string is a substring of another (e.g., "Dream" vs "Dream On")
  - Default similarity threshold of 0.8 works well for common typos while avoiding false positives
  - Import SpotifyTrack type from @/types to maintain consistency with the type system
---

## 2026-01-15 - US-023
- What was implemented: Spotify search API endpoint for batch song searches
- Files changed:
  - src/app/api/spotify/search/route.ts - POST handler for searching multiple songs on Spotify with concurrency control
- **Learnings for future iterations:**
  - Use a simple executeWithConcurrency helper to limit parallel async operations (avoids rate limiting)
  - SpotifySearchResult and SpotifySearchResponse types were already defined in @/types - reuse existing types
  - Include both error code (AUTH_ERROR, RATE_LIMIT, SPOTIFY_ERROR) and message in error responses for better client handling
  - Pass Retry-After header through from SpotifyRateLimitError for proper backoff in clients
  - Validate each song in array individually to provide clear error messages with index
---

## 2026-01-15 - US-024
- What was implemented: Spotify playlist API endpoint for creating and updating playlists
- Files changed:
  - src/app/api/spotify/playlist/route.ts - POST handler for creating playlists, PUT handler for updating existing playlists
  - src/lib/spotify/api.ts - Added getCurrentUser(), createPlaylist(), addTracksToPlaylist(), removeTracksFromPlaylist() methods
- **Learnings for future iterations:**
  - Spotify requires user ID to create a playlist - use `/me` endpoint to get current user's ID first
  - Spotify playlist API limits: name max 100 chars, description max 300 chars, max 100 tracks per add/remove request
  - Use batch helper functions (addTracksInBatches, removeTracksInBatches) to handle large numbers of tracks
  - Spotify track URIs have format `spotify:track:TRACKID` - validate with regex before sending to API
  - When updating playlists, remove tracks first then add - avoids accidentally adding then removing same track
  - The `delete` method for removing tracks requires body with `{ tracks: [{ uri }] }` format, not just URI strings
  - Construct playlist URL manually for PUT responses: `https://open.spotify.com/playlist/${playlistId}`
---

## 2026-01-15 - US-025
- What was implemented: Spotify recommendations API for "More Like This" feature
- Files changed:
  - src/lib/spotify/api.ts - Added getRecommendations(seedTrackId, limit) method
  - src/lib/spotify/api.test.ts - Added 14 tests for getRecommendations method
- **Learnings for future iterations:**
  - Spotify recommendations API endpoint: `/recommendations?seed_tracks={trackId}&limit={limit}`
  - The limit parameter is clamped to 1-100 range (Spotify's valid range), default 20
  - The track ID should be URL encoded when constructing the query string
  - Response structure: `{ tracks: SpotifyTrack[] }` - same SpotifyTrack type as search results
  - The response may have null/undefined tracks property - always use `|| []` fallback
---

## 2026-01-15 - US-026
- What was implemented: Playlist Zustand store for managing playlist state
- Files changed:
  - src/store/playlistStore.ts - Zustand store with playlist name, spotifyPlaylistId, isOwned, and songs state
  - src/store/playlistStore.test.ts - 43 tests covering all actions and state transitions
- **Learnings for future iterations:**
  - PlaylistSong type uses SongState ('synced' | 'pending' | 'markedForRemoval') to track sync status
  - generateSongId() creates unique IDs with timestamp + random string pattern: `song_${Date.now()}_${random}`
  - loadSongs(songs, isOwned) replaces all songs - use this when loading existing playlists from Spotify
  - addSongs(songs) appends songs with 'pending' state - use this when adding from candidates
  - toggleRemoval only works on synced/markedForRemoval songs, not pending songs
  - removePending only removes songs that are both matching ID AND in 'pending' state
  - clearPlaylist resets all state including isOwned back to true (for "New Playlist" flow)
  - markPendingAsSynced and removeMarkedSongs are helper methods for post-sync state updates
---

## 2026-01-15 - US-027
- What was implemented: Candidate Zustand store for managing current generation candidates
- Files changed:
  - src/store/candidateStore.ts - Zustand store with candidates array, isLoading state, and all actions/selectors
  - src/store/candidateStore.test.ts - 35 tests covering all actions and selectors
- **Learnings for future iterations:**
  - CandidateSong type from @/types includes isMatched and isSelected for managing selection state
  - generateCandidateId() follows same pattern as playlist: `candidate_${Date.now()}_${random}`
  - setCandidates replaces all candidates and sets isLoading to false - call setLoading(true) before starting generation
  - toggleSelection only works on matched songs - unmatched songs cannot be selected
  - selectAll and deselectAll are convenience methods for bulk selection operations
  - getSelectedCandidates selector filters for both isMatched AND isSelected
  - getMatchRate selector returns { matched, total, percentage } for display in UI
  - Use standalone selector functions (not store methods) for derived data: `getSelectedCandidates(useCandidateStore.getState())`
---

## 2026-01-15 - US-028
- What was implemented: usePlaylist hook for managing playlist with addSelectedToPlaylist functionality
- Files changed:
  - src/hooks/usePlaylist.ts - created hook with addSelectedToPlaylist, clearPlaylist, and selectors for hasPendingChanges/songCounts
  - src/hooks/usePlaylist.test.ts - 22 tests covering all functionality
- **Learnings for future iterations:**
  - Candidate selector `getSelectedCandidates(state)` requires passing full state object { candidates, isLoading }
  - When getting candidates from hook, use `useCandidateStore((state) => state.candidates)` to get reactive value
  - addSongs from playlistStore requires spotifyTrack to be non-null, so filter candidates first
  - clearPlaylist should clear both playlistStore and candidateStore for "New Playlist" flow
  - songCounts helper provides counts by state (synced, pending, markedForRemoval, total) for UI display
  - hasPendingChanges checks for any pending or markedForRemoval songs to determine if sync is needed
---

## 2026-01-15 - US-029
- What was implemented: Session persistence in localStorage using Zustand persist middleware
- Files changed:
  - src/store/playlistStore.ts - added persist middleware with createJSONStorage, partialize config
  - src/store/playlistStore.test.ts - added 8 tests for persistence behavior
- **Learnings for future iterations:**
  - Use `persist()` and `createJSONStorage()` from 'zustand/middleware' for localStorage persistence
  - Wrap store creator with `create<Type>()()` (extra parens) when using middleware
  - Use `partialize` option to specify which state properties to persist (exclude actions)
  - Export storage key constant (PLAYLIST_STORAGE_KEY) for use in tests
  - When testing persist, localStorage.setItem is called multiple times - use `.filter().pop()` to get LAST call with the storage key
  - Use `usePlaylistStore.persist.rehydrate()` to trigger rehydration from mocked localStorage in tests
  - Zustand persist stores data as `{ state: {...}, version: 0 }` structure
---

## 2026-01-15 - US-030
- What was implemented: New Playlist flow wiring up UI to real stores
- Files changed:
  - src/app/page.tsx - converted to client component, wired up to usePlaylist hook and useCandidateStore
  - src/components/layout/LeftPanel.tsx - changed playlistName prop from initialPlaylistName (uncontrolled) to controlled, added handleNewPlaylist to clear prompt
- **Learnings for future iterations:**
  - When converting page.tsx to use hooks, add 'use client' directive at the top
  - For controlled form inputs, parent component provides value and onChange handler - no useState inside child
  - usePlaylist hook's clearPlaylist() already clears both playlistStore and candidateStore
  - LeftPanel needs to clear its own internal prompt state separately since it's local state
  - The pattern of passing store actions as callbacks (onNewPlaylist, onPlaylistNameChange) keeps components reusable
  - Browser verification confirmed: localStorage is properly updated when clearPlaylist is called
---

## 2026-01-15 - US-031
- What was implemented: Added getUserPlaylists() method to SpotifyClient for fetching user's playlists
- Files changed:
  - src/lib/spotify/api.ts - added getUserPlaylists(limit) method with pagination support, added SpotifyPlaylistItem and SpotifyPlaylistsResponse interfaces
  - src/lib/spotify/api.test.ts - added 18 tests for getUserPlaylists covering all scenarios
  - src/types/index.ts - added UserPlaylist interface with id, name, owner, isOwned, images, and tracks fields
- **Learnings for future iterations:**
  - Spotify /me/playlists endpoint returns paginated results with max 50 items per request
  - Use `next` property from response to determine if more pages are available
  - Compare owner.id with current user's ID (from /me endpoint) to determine isOwned flag
  - The response may have null values for images, tracks, display_name - always use fallbacks (|| [] or || 0)
  - When testing multiple sequential fetch calls, use mockFetch.mockReset() in beforeEach for proper isolation
  - Use chained .mockResolvedValueOnce() calls for tests that make multiple sequential API requests
---

## 2026-01-15 - US-032
- What was implemented: Added getPlaylistTracks() method to SpotifyClient for fetching tracks from an existing playlist
- Files changed:
  - src/lib/spotify/api.ts - added getPlaylistTracks(playlistId, limit) method with pagination support, added SpotifyPlaylistTrackItem and SpotifyPlaylistTracksResponse interfaces
  - src/lib/spotify/api.test.ts - added 15 tests for getPlaylistTracks covering all scenarios
- **Learnings for future iterations:**
  - Spotify /playlists/{id}/tracks endpoint returns paginated results with max 100 items per request
  - The response items have a `track` property that can be null (for deleted/unavailable tracks) - always check for null before adding to results
  - Use `next` property from response to determine if more pages are available
  - Response structure: `{ items: [{ track: SpotifyTrack | null, added_at, added_by }], next, ... }`
  - Pagination pattern similar to getUserPlaylists but with 100 max per page instead of 50
---

## 2026-01-15 - US-033
- What was implemented: Load Existing Playlist flow - dropdown to select user's playlists, fetch tracks from Spotify, populate right panel
- Files changed:
  - src/app/api/spotify/playlists/route.ts - created GET endpoint to fetch user's playlists with accessToken query param
  - src/app/api/spotify/playlists/[playlistId]/tracks/route.ts - created GET endpoint to fetch playlist tracks
  - src/components/layout/LeftPanel.tsx - updated dropdown to show playlists with track count and lock icon for followed
  - src/app/page.tsx - added fetchUserPlaylists on auth, handleLoadExisting to load tracks and populate store
- **Learnings for future iterations:**
  - Next.js 16 dynamic route params are async - use `const { playlistId } = await params` in route handlers
  - Pass accessToken via query params for GET requests (can't use body)
  - Convert SpotifyTrack to Song format: title=name, artist=artists.map(...).join(', '), album=album.name
  - For followed (read-only) playlists: clear playlist ID, clear name, songs get 'pending' state (loadSongs with isOwned=false)
  - For owned playlists: set playlist ID, set name, songs get 'synced' state (loadSongs with isOwned=true)
---
